(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{457:function(t,s,a){"use strict";a.r(s);var e=a(2),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("对象!!还是要有一个~\n")]),t._v(" "),s("h2",{attrs:{id:"构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[t._v("#")]),t._v(" 构造函数：")]),t._v(" "),s("ul",[s("li",[t._v("构造函数函数名的首字母最好大写，这是为了方便我们区分构造函数和其他非构造函数")]),t._v(" "),s("li",[t._v("构造函数使用this关键字来给它将创建的这个对象设置新的属性。在构造函数里面，this指向的就是它新创建的这个对象。")]),t._v(" "),s("li",[t._v("构造函数定义了属性和行为就可创建对象，而不是像其他函数一样需要设置返回值。")]),t._v(" "),s("li",[t._v("通过构造函数创建对象的时候要使用new操作符。")])]),t._v(" "),s("h2",{attrs:{id:"constructor属性是对创建这个实例的构造函数的一个引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#constructor属性是对创建这个实例的构造函数的一个引用"}},[t._v("#")]),t._v(" constructor属性是对创建这个实例的构造函数的一个引用")]),t._v(" "),s("ul",[s("li",[t._v("凡是手动给新对象重新设置过原型对象的，都别忘记在原型对象中定义一个fFUNCname.prototype.constructor属性;")]),t._v(" "),s("li",[t._v("原型是一个对象，所以原型对象也有它自己的原型！这样看来的话，Bird.prototype的原型就是Object.prototype;")])]),t._v(" "),s("h2",{attrs:{id:"object是-javascript-中所有对象的父级-也就是原型链的最顶层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object是-javascript-中所有对象的父级-也就是原型链的最顶层"}},[t._v("#")]),t._v(" Object是 JavaScript 中所有对象的父级，也就是原型链的最顶层")]),t._v(" "),s("h2",{attrs:{id:"object-create-proto-propertiesobject"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-create-proto-propertiesobject"}},[t._v("#")]),t._v(" Object.create(proto [, propertiesObject ])")]),t._v(" "),s("ul",[s("li",[t._v("是E5中提出的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个null，第二个参数是对象的属性描述符，这个参数是可选的。")]),t._v(" "),s("li",[t._v("bject.create(obj)创建了一个新对象，并指定了obj作为新对象的原型。")]),t._v(" "),s("li",[t._v("let animal = Object.create(Animal.prototype);")]),t._v(" "),s("li",[t._v("不相关对象的相同方法,可以定义一个函数内部继续函数调用一个方法,然后把对象传进去,对象引用方法便是;")]),t._v(" "),s("li",[t._v("对于不相关的对象，更好的方法是使用mixins。mixin允许其他对象使用函数集合。")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('let flyMixin = function(obj) {\n  obj.fly = function() {\n    console.log("Flying, wooosh!");\n  }\n};\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h2",{attrs:{id:"a-prototype-isprototypeof-b"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-prototype-isprototypeof-b"}},[t._v("#")]),t._v(" A.prototype.isPrototypeOf(B)")]),t._v(" "),s("ul",[s("li",[t._v("作用：检测一个[A]对象是否是另一个对象[B]的原型。或者说一个对象是否被包含在另一个对象的原型链中")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("var p = {x:1};//定义一个原型对象\nvar o = Object.create(p);//使用这个原型创建一个对象\np.isPrototypeOf(o);//=>true：o继承p\nObject.prototype.isPrototypeOf(p);//=> true p继承自Object.prototype\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h2",{attrs:{id:"hasownproperty"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hasownproperty"}},[t._v("#")]),t._v(" hasOwnProperty")]),t._v(" "),s("ul",[s("li",[t._v("对象的hasOwnProperty()方法用来检测给定的名字是否是对象的自由属性(自己的属性true)，如果是继承属性则返回false")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('let ownProps = [];\n\nfor (let property in duck) {\n  if(duck.hasOwnProperty(property)) {\n    ownProps.push(property);\n  }\n}\n\nconsole.log(ownProps); // prints [ "name", "numLegs" ]\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("ul",[s("li",[t._v("使属性私有化最简单的方法就是在构造函数中创建变量。可以将该变量范围限定在构造函数中，而不是全局可用。这样，属性只能由构造函数中的方法访问和更改。")]),t._v(" "),s("li",[t._v("在 JavaScript 中，函数总是可以访问创建它的上下文。这就叫做闭包.")])]),t._v(" "),s("h2",{attrs:{id:"立即执行函数-iife"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#立即执行函数-iife"}},[t._v("#")]),t._v(" 立即执行函数(IIFE)")]),t._v(" "),s("ul",[s("li",[t._v("两种常见形式：( function(){…} )()和( function (){…}())，")]),t._v(" "),s("li",[t._v("一个是一个匿名函数包裹在一个括号运算符中，后面再跟一个小括号")]),t._v(" "),s("li",[t._v("另一个是一个匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中")]),t._v(" "),s("li",[t._v("这两种写法是等价的,要想立即执行函数能做到立即执行")]),t._v(" "),s("li",[t._v("要注意两点:一是函数体后面要有小括号()")]),t._v(" "),s("li",[t._v("二是函数体必须是函数表达式而不能是函数声明")]),t._v(" "),s("li",[t._v("可以用除了使用()运算符之外，！，+，-，=等运算符,将匿名函数或函数声明转换为函数表达式")])]),t._v(" "),s("h2",{attrs:{id:"使用立即执行函数的好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用立即执行函数的好处"}},[t._v("#")]),t._v(" 使用立即执行函数的好处")]),t._v(" "),s("ul",[s("li",[t._v("通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。此时若是想访问全局对象，将全局对象以参数形式传进去即可\n如jQuery代码结构:")])])])}),[],!1,null,null,null);s.default=r.exports}}]);