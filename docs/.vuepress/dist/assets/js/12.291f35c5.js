(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{430:function(t,v,_){t.exports=_.p+"assets/img/react.842d6060.png"},444:function(t,v,_){"use strict";_.r(v);var a=_(2),e=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"框架相关"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#框架相关"}},[t._v("#")]),t._v(" 框架相关")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[t._v("Angular = React/Vue + 路由库（react-router/vue-router） + 状态管理（Redux/Flux/Mobx/Vuex） + 脚手架/构建（create-react-app/Vue CLI/Webpack） + ...\n")])])]),v("h2",{attrs:{id:"angular-状态更新-脏检查机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#angular-状态更新-脏检查机制"}},[t._v("#")]),t._v(" Angular 状态更新：脏检查机制")]),t._v(" "),v("ul",[v("li",[t._v("什么是脏检查呢？在 Angular 中，触发视图更新的时机来自常见的事件如用户交互（点击、输入等）、定时器、生命周期等，大概的过程如下：\n"),v("ol",[v("li",[t._v("在上述时机被触发后，Angular会计算数据的新值和旧值是否有差异；")]),t._v(" "),v("li",[t._v("若有差异，Angular 会更新页面，并触发下一次的脏检查；")]),t._v(" "),v("li",[t._v("直到新旧值之间不再有差异，或是脏检查的次数达到设定阈值，才会停下来。")])])]),t._v(" "),v("li",[t._v("由于并不是直接监听数据的变动，同时每一次更新页面之后，很可能还会引起新的值改变，这导致脏检查的效率很低，还可能会导致死循环。")]),t._v(" "),v("li",[t._v("虽然 AngularJS 有阈值控制，但也无法避免脏检查机制所导致的低效甚至性能问题。")]),t._v(" "),v("li",[t._v("脏检查机制在设计上存在的性能问题一直被大家诟病，在 Angular2+ 中引入了模块化组织来解决这个问题。")]),t._v(" "),v("li",[t._v("由于应用的组织类是树结构的，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查。")]),t._v(" "),v("li",[t._v("相比 AngularJS 中的带有环的结构，这样的单向数据流效率更高，而且容易预测，性能上也有不少的提升。")]),t._v(" "),v("li",[t._v("除了模块化组织之外，Angular2+ 同时还引入了 NgZone，提升了脏检查的性能。")])]),t._v(" "),v("h2",{attrs:{id:"react"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),v("h3",{attrs:{id:"虚拟-dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[t._v("#")]),t._v(" 虚拟 DOM")]),t._v(" "),v("ul",[v("li",[t._v("虚拟 DOM 方案的出现，主要为了解决前端页面频繁渲染过程中的性能问题。\n虚拟 DOM的设计，大概可分成 3 个过程")])]),t._v(" "),v("ol",[v("li",[t._v("用JavaScript 对象模拟 DOM 树，得到一棵虚拟 DOM 树。\n"),v("ul",[v("li",[t._v("不知道你是否仔细研究过 DOM 节点对象，一个真正的DOM 元素非常庞大，拥有很多的属性值。一个 DOM 节点包括特别多的属性、元素和事件对象，但实际上我们会用到的可能只有其中很小一部分，比如节点内容、元素位置、样式、节点的添加删除等方法。\n所以，我们通过用 JavaScript 对象来表示 DOM 元素的方式，该对象仅包括常用的这些属性方法和节点关系，这样就可以大大降低对象内存、虚拟 DOM 差异对比的计算量等。")])])]),t._v(" "),v("li",[t._v("当页面数据变更时，生成新的虚拟 DOM 树，比较新旧两棵虚拟 DOM 树的差异。\n"),v("ul",[v("li",[t._v("当我们用 JavaScript 对象来模拟 DOM 节点之后，可以构造出虚拟 DOM 树。\n当发生状态变更的时候，可以重新构造一棵新的 JavaScript 对象 DOM 树。通过将新的模拟 DOM 树和旧的模拟 DOM 树进行比较，得到两棵树的差异，并记录下来。在比较之后，我们可以获得这样的差异：\n"),v("ul",[v("li",[t._v("需要替换掉原来的节点；")]),t._v(" "),v("li",[t._v("移动、删除、新增子节点；")]),t._v(" "),v("li",[t._v("修改了节点的属性；")]),t._v(" "),v("li",[t._v("对于文本节点的文本内容改变。\n"),v("img",{attrs:{src:_(430)}})])])])])])]),t._v(" "),v("p",[t._v("如图所示，我们对比了两棵基于"),v("code",[t._v("<div>")]),t._v("元素的DOM 树，得到的差异有：")]),t._v(" "),v("ul",[v("li",[t._v("p 元素插入了一个 span 元素子节点；")]),t._v(" "),v("li",[t._v("原先的文本节点挪到了 span 元素子节点下面；")])]),t._v(" "),v("p",[t._v("经过差异对比之后，我们能获得一组差异记录，接下来我们需要使用它。")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("把差异应用到真正的 DOM 树上")])]),t._v(" "),v("ul",[v("li",[t._v("要实现最终的页面渲染，需要进行一些 JavaScript 操作，将差异应用到真正的DOM 树上，例如节点的替换、移动、删除，文本内容的改变等。")]),t._v(" "),v("li",[t._v("使用这样的方式来更新页面，可以将页面的DOM 变更范围减到最小，同时通过将多个状态变更合并计算，可以降低页面的更新频率。因此，使用虚拟 DOM，可以有效降低浏览器计算和性能。")]),t._v(" "),v("li",[t._v("虽然虚拟 DOM 解决了页面被频繁更新和渲染带来的性能问题，但传统虚拟 DOM 依然有以下性能瓶颈：\n"),v("ul",[v("li",[t._v("在单个组件内部依然需要遍历该组件的整个虚拟 DOM 树；")]),t._v(" "),v("li",[t._v("在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费；")]),t._v(" "),v("li",[t._v("递归遍历和更新逻辑容易导致 UI 渲染被阻塞，用户体验下降。")])])])]),t._v(" "),v("p",[t._v("对此，React 框架也有进行相应的优化：使用任务调度来控制状态更新的计算和渲染。")]),t._v(" "),v("h3",{attrs:{id:"状态更新-任务调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#状态更新-任务调度"}},[t._v("#")]),t._v(" 状态更新：任务调度")]),t._v(" "),v("ul",[v("li",[t._v("React 中使用协调器（Reconciler）与渲染器（Renderer）来优化页面的渲染性能。")]),t._v(" "),v("li",[t._v("在 React 里，可以使用ReactDOM.render/this.setState/this.forceUpdate/useState等方法来触发状态更新，这些方法共用一套状态更新机制，该更新机制主要由两个步骤组成。")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("找出变化的组件，每当有更新发生时，协调器会做如下工作：")]),t._v(" "),v("ul",[v("li",[t._v("调用组件render方法将 JSX 转化为虚拟 DOM；")]),t._v(" "),v("li",[t._v("进行虚拟 DOM Diff 并找出变化的虚拟 DOM；")]),t._v(" "),v("li",[t._v("通知渲染器。")])])]),t._v(" "),v("li",[v("p",[t._v("渲染器接到协调器通知，将变化的组件渲染到页面上。")]),t._v(" "),v("ul",[v("li",[t._v("在 React15 及以前，协调器创建虚拟 DOM 使用的是递归的方式，该过程是无法中断的。这会导致 UI 渲染被阻塞，造成卡顿。")]),t._v(" "),v("li",[t._v("为此，React16 中新增了调度器（Scheduler），调度器能够把可中断的任务切片处理，能够调整优先级，重置并复用任务。")]),t._v(" "),v("li",[t._v("调度器会根据任务的优先级去分配各自的过期时间，在过期时间之前按照优先级执行任务，可以在不影响用户体验的情况下去进行计算和更新。")])])])]),t._v(" "),v("p",[t._v("通过这样的方式，React 可在浏览器空闲的时候进行调度并执行任务")]),t._v(" "),v("ul",[v("li",[t._v("虚拟DOM和任务调度的状态更新机制，是 React 中性能优化的两个重要解决方案。")]),t._v(" "),v("li",[t._v("除了性能优化以外，React 的出现同时带来的理念和设计，包括 jsx、函数式编程、Hooks等。")])]),t._v(" "),v("h2",{attrs:{id:"vue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),v("h3",{attrs:{id:"虚拟-dom-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-2"}},[t._v("#")]),t._v(" 虚拟 DOM")]),t._v(" "),v("ul",[v("li",[t._v("在 Vue 3.0 中，虚拟 DOM通过动静结合的模式来进行突破：\n"),v("ul",[v("li",[t._v("通过模版静态分析生成更优化的虚拟 DOM 渲染函数，将模版切分为块（if/for/slot)；")]),t._v(" "),v("li",[t._v("更新时只需要直接遍历动态节点，虚拟 DOM的更新性能与模版大小解耦，变为与动态节点的数量相关。")]),t._v(" "),v("li",[t._v("可以简单理解为，虚拟 DOM 的更新从以前的整体作用域调整为树状作用域，树状的结构会带来算法的简化以及性能的提升。")])])])]),t._v(" "),v("h3",{attrs:{id:"状态更新-getter-setter、proxy"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#状态更新-getter-setter、proxy"}},[t._v("#")]),t._v(" 状态更新：getter/setter、Proxy")]),t._v(" "),v("ul",[v("li",[t._v("在 Vue 3.0 以前，Vue中状态更新实现主要依赖了getter/setter，在数据更新的时候就执行了模板更新、watch、computed等一些工作。\n"),v("ul",[v("li",[t._v("相比于之前的getter/setter监控数据变更，Vue 3.0 将会是基于Proxy的变动侦测，通过代理的方式来监控变动，整体性能会得到优化。")]),t._v(" "),v("li",[t._v("当我们给某个对象添加了代理之后，就可以改变一些原有的行为，或是通过钩子的方式添加一些处理，用来触发界面更新、其他数据更新等")])])])])])}),[],!1,null,null,null);v.default=e.exports}}]);