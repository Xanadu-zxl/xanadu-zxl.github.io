<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.48">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/favicon.ico"><title>框架相关 | 逆水行舟丨</title><meta name="description" content="进入博客 🔥">
    <link rel="modulepreload" href="/assets/app.38db9df0.js"><link rel="modulepreload" href="/assets/index.html.101cc35c.js"><link rel="modulepreload" href="/assets/index.html.96c06973.js"><link rel="prefetch" href="/assets/index.html.e11e7896.js"><link rel="prefetch" href="/assets/Less.html.30d7800c.js"><link rel="prefetch" href="/assets/css.html.22d39078.js"><link rel="prefetch" href="/assets/cssSenior.html.7ce850fc.js"><link rel="prefetch" href="/assets/Vue-router.html.42e9a27c.js"><link rel="prefetch" href="/assets/Vue.html.f290e390.js"><link rel="prefetch" href="/assets/Vue3.html.bf1a729c.js"><link rel="prefetch" href="/assets/HTML.html.6ea8110c.js"><link rel="prefetch" href="/assets/Advance.html.5d0193a6.js"><link rel="prefetch" href="/assets/Axios.html.8aae4cbc.js"><link rel="prefetch" href="/assets/DesignPatterns.html.7727f1ba.js"><link rel="prefetch" href="/assets/ES6.html.2f4a699b.js"><link rel="prefetch" href="/assets/JavaScript.html.af2f13bf.js"><link rel="prefetch" href="/assets/Jquery.html.c5fbf4f3.js"><link rel="prefetch" href="/assets/Object.html.c46d86d5.js"><link rel="prefetch" href="/assets/index.html.d339c84b.js"><link rel="prefetch" href="/assets/RegExp.html.ef182708.js"><link rel="prefetch" href="/assets/TypeScript.html.c521707c.js"><link rel="prefetch" href="/assets/VueRouter路由.html.3d26e6ba.js"><link rel="prefetch" href="/assets/404.html.7d858b3d.js"><link rel="prefetch" href="/assets/index.html.b6a713bd.js"><link rel="prefetch" href="/assets/Less.html.df4d602e.js"><link rel="prefetch" href="/assets/css.html.2dd6903c.js"><link rel="prefetch" href="/assets/cssSenior.html.e5afb89c.js"><link rel="prefetch" href="/assets/Vue-router.html.252d8654.js"><link rel="prefetch" href="/assets/Vue.html.4d641e80.js"><link rel="prefetch" href="/assets/Vue3.html.81cae9d1.js"><link rel="prefetch" href="/assets/HTML.html.2da4bcdd.js"><link rel="prefetch" href="/assets/Advance.html.d2eacb74.js"><link rel="prefetch" href="/assets/Axios.html.443e3443.js"><link rel="prefetch" href="/assets/DesignPatterns.html.dd3d7a98.js"><link rel="prefetch" href="/assets/ES6.html.6853f7e1.js"><link rel="prefetch" href="/assets/JavaScript.html.9fe72908.js"><link rel="prefetch" href="/assets/Jquery.html.3b6b8e40.js"><link rel="prefetch" href="/assets/Object.html.80b9b461.js"><link rel="prefetch" href="/assets/index.html.0c1bbc9d.js"><link rel="prefetch" href="/assets/RegExp.html.ce0fc241.js"><link rel="prefetch" href="/assets/TypeScript.html.abcdb63f.js"><link rel="prefetch" href="/assets/VueRouter路由.html.b1e5cdb1.js"><link rel="prefetch" href="/assets/404.html.e815a148.js"><link rel="prefetch" href="/assets/404.af207cc0.js"><link rel="prefetch" href="/assets/Layout.e85c5736.js">
    <link rel="stylesheet" href="/assets/style.acf36ec1.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">逆水行舟丨</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="主页"><!--[--><!--]--> 主页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://juejin.cn/user/3624450346452542" rel="noopener noreferrer" target="_blank" aria-label="掘金"><!--[--><!--]--> 掘金 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/zxl7" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="主页"><!--[--><!--]--> 主页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://juejin.cn/user/3624450346452542" rel="noopener noreferrer" target="_blank" aria-label="掘金"><!--[--><!--]--> 掘金 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/zxl7" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/mian/" class="sidebar-item sidebar-heading collapsible" aria-label="框架相关"><!--[--><!--]--> 框架相关 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/mian/VueRouter路由.md" class="sidebar-item" aria-label="VueRouter路由原理"><!--[--><!--]--> VueRouter路由原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="框架相关" tabindex="-1"><a class="header-anchor" href="#框架相关" aria-hidden="true">#</a> 框架相关</h1><pre><code>Angular = React/Vue + 路由库（react-router/vue-router） + 状态管理（Redux/Flux/Mobx/Vuex） + 脚手架/构建（create-react-app/Vue CLI/Webpack） + ...
</code></pre><h2 id="angular-状态更新-脏检查机制" tabindex="-1"><a class="header-anchor" href="#angular-状态更新-脏检查机制" aria-hidden="true">#</a> Angular 状态更新：脏检查机制</h2><ul><li>什么是脏检查呢？在 Angular 中，触发视图更新的时机来自常见的事件如用户交互（点击、输入等）、定时器、生命周期等，大概的过程如下： <ol><li>在上述时机被触发后，Angular会计算数据的新值和旧值是否有差异；</li><li>若有差异，Angular 会更新页面，并触发下一次的脏检查；</li><li>直到新旧值之间不再有差异，或是脏检查的次数达到设定阈值，才会停下来。</li></ol></li><li>由于并不是直接监听数据的变动，同时每一次更新页面之后，很可能还会引起新的值改变，这导致脏检查的效率很低，还可能会导致死循环。</li><li>虽然 AngularJS 有阈值控制，但也无法避免脏检查机制所导致的低效甚至性能问题。</li><li>脏检查机制在设计上存在的性能问题一直被大家诟病，在 Angular2+ 中引入了模块化组织来解决这个问题。</li><li>由于应用的组织类是树结构的，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查。</li><li>相比 AngularJS 中的带有环的结构，这样的单向数据流效率更高，而且容易预测，性能上也有不少的提升。</li><li>除了模块化组织之外，Angular2+ 同时还引入了 NgZone，提升了脏检查的性能。</li></ul><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h2><h3 id="虚拟-dom" tabindex="-1"><a class="header-anchor" href="#虚拟-dom" aria-hidden="true">#</a> 虚拟 DOM</h3><ul><li>虚拟 DOM 方案的出现，主要为了解决前端页面频繁渲染过程中的性能问题。 虚拟 DOM的设计，大概可分成 3 个过程</li></ul><ol><li>用JavaScript 对象模拟 DOM 树，得到一棵虚拟 DOM 树。 <ul><li>不知道你是否仔细研究过 DOM 节点对象，一个真正的DOM 元素非常庞大，拥有很多的属性值。一个 DOM 节点包括特别多的属性、元素和事件对象，但实际上我们会用到的可能只有其中很小一部分，比如节点内容、元素位置、样式、节点的添加删除等方法。 所以，我们通过用 JavaScript 对象来表示 DOM 元素的方式，该对象仅包括常用的这些属性方法和节点关系，这样就可以大大降低对象内存、虚拟 DOM 差异对比的计算量等。</li></ul></li><li>当页面数据变更时，生成新的虚拟 DOM 树，比较新旧两棵虚拟 DOM 树的差异。 <ul><li>当我们用 JavaScript 对象来模拟 DOM 节点之后，可以构造出虚拟 DOM 树。 当发生状态变更的时候，可以重新构造一棵新的 JavaScript 对象 DOM 树。通过将新的模拟 DOM 树和旧的模拟 DOM 树进行比较，得到两棵树的差异，并记录下来。在比较之后，我们可以获得这样的差异： <ul><li>需要替换掉原来的节点；</li><li>移动、删除、新增子节点；</li><li>修改了节点的属性；</li><li>对于文本节点的文本内容改变。</li></ul></li></ul></li></ol><p>如图所示，我们对比了两棵基于<code>&lt;div&gt;</code>元素的DOM 树，得到的差异有：</p><ul><li>p 元素插入了一个 span 元素子节点；</li><li>原先的文本节点挪到了 span 元素子节点下面；</li></ul><p>经过差异对比之后，我们能获得一组差异记录，接下来我们需要使用它。</p><ol start="3"><li>把差异应用到真正的 DOM 树上</li></ol><ul><li>要实现最终的页面渲染，需要进行一些 JavaScript 操作，将差异应用到真正的DOM 树上，例如节点的替换、移动、删除，文本内容的改变等。</li><li>使用这样的方式来更新页面，可以将页面的DOM 变更范围减到最小，同时通过将多个状态变更合并计算，可以降低页面的更新频率。因此，使用虚拟 DOM，可以有效降低浏览器计算和性能。</li><li>虽然虚拟 DOM 解决了页面被频繁更新和渲染带来的性能问题，但传统虚拟 DOM 依然有以下性能瓶颈： <ul><li>在单个组件内部依然需要遍历该组件的整个虚拟 DOM 树；</li><li>在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费；</li><li>递归遍历和更新逻辑容易导致 UI 渲染被阻塞，用户体验下降。</li></ul></li></ul><p>对此，React 框架也有进行相应的优化：使用任务调度来控制状态更新的计算和渲染。</p><h3 id="状态更新-任务调度" tabindex="-1"><a class="header-anchor" href="#状态更新-任务调度" aria-hidden="true">#</a> 状态更新：任务调度</h3><ul><li>React 中使用协调器（Reconciler）与渲染器（Renderer）来优化页面的渲染性能。</li><li>在 React 里，可以使用ReactDOM.render/this.setState/this.forceUpdate/useState等方法来触发状态更新，这些方法共用一套状态更新机制，该更新机制主要由两个步骤组成。</li></ul><ol><li><p>找出变化的组件，每当有更新发生时，协调器会做如下工作：</p><ul><li>调用组件render方法将 JSX 转化为虚拟 DOM；</li><li>进行虚拟 DOM Diff 并找出变化的虚拟 DOM；</li><li>通知渲染器。</li></ul></li><li><p>渲染器接到协调器通知，将变化的组件渲染到页面上。</p><ul><li>在 React15 及以前，协调器创建虚拟 DOM 使用的是递归的方式，该过程是无法中断的。这会导致 UI 渲染被阻塞，造成卡顿。</li><li>为此，React16 中新增了调度器（Scheduler），调度器能够把可中断的任务切片处理，能够调整优先级，重置并复用任务。</li><li>调度器会根据任务的优先级去分配各自的过期时间，在过期时间之前按照优先级执行任务，可以在不影响用户体验的情况下去进行计算和更新。</li></ul></li></ol><p>通过这样的方式，React 可在浏览器空闲的时候进行调度并执行任务</p><ul><li>虚拟DOM和任务调度的状态更新机制，是 React 中性能优化的两个重要解决方案。</li><li>除了性能优化以外，React 的出现同时带来的理念和设计，包括 jsx、函数式编程、Hooks等。</li></ul><h2 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h2><h3 id="虚拟-dom-1" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-1" aria-hidden="true">#</a> 虚拟 DOM</h3><ul><li>在 Vue 3.0 中，虚拟 DOM通过动静结合的模式来进行突破： <ul><li>通过模版静态分析生成更优化的虚拟 DOM 渲染函数，将模版切分为块（if/for/slot)；</li><li>更新时只需要直接遍历动态节点，虚拟 DOM的更新性能与模版大小解耦，变为与动态节点的数量相关。</li><li>可以简单理解为，虚拟 DOM 的更新从以前的整体作用域调整为树状作用域，树状的结构会带来算法的简化以及性能的提升。</li></ul></li></ul><h3 id="状态更新-getter-setter、proxy" tabindex="-1"><a class="header-anchor" href="#状态更新-getter-setter、proxy" aria-hidden="true">#</a> 状态更新：getter/setter、Proxy</h3><ul><li>在 Vue 3.0 以前，Vue中状态更新实现主要依赖了getter/setter，在数据更新的时候就执行了模板更新、watch、computed等一些工作。 <ul><li>相比于之前的getter/setter监控数据变更，Vue 3.0 将会是基于Proxy的变动侦测，通过代理的方式来监控变动，整体性能会得到优化。</li><li>当我们给某个对象添加了代理之后，就可以改变一些原有的行为，或是通过钩子的方式添加一些处理，用来触发界面更新、其他数据更新等</li></ul></li></ul></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: zxlcoder@gamil.com">zxl7</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: zxlcoder@gmail.com">郑薛林</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.38db9df0.js" defer></script>
  </body>
</html>
